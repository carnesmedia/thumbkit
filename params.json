{"name":"Thumbkit","body":"# Thumbkit\r\n\r\nThumbkit provides a unified API for generating thumbnail images from image, audio, and text sources.\r\nIt plays nicely with Carrierwave out of the box, but doesn't require it.\r\n\r\n> it's like quicklook for carrierwave :)\r\n>\r\n> -- <cite>[Emmanuel Gomez][1]</cite>\r\n\r\n [1]:https://github.com/emmanuel\r\n\r\n## Synopsis\r\n\r\n```ruby\r\nThumbkit.new('path/to/audio.mp3').write_thumbnail # => 'path/to/audio.png'\r\nThumbkit.new('path/to/text.txt').write_thumbnail  # => 'path/to/text.png'\r\nThumbkit.new('path/to/image.jpg').write_thumbnail # => 'path/to/image.jpg'\r\n```\r\n\r\nSee [Usage](#usage) below for more examples\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n```ruby\r\ngem 'thumbkit'\r\ngem 'mini_magick' # For text or image thumbnails\r\ngem 'waveform' # For audio thumbnails\r\ngem 'oily_png' # Optional, for presumably faster audio thumbnails\r\n```\r\n\r\nAnd then execute:\r\n\r\n```shell\r\n$ bundle\r\n```\r\n\r\nPlease see [Requirements](#requirements) for more information about each\r\nthumbnail type.\r\n\r\n\r\n## Requirements\r\n\r\n### Image thumbnails\r\n\r\nThumbkit uses [MiniMagick](https://github.com/probablycorey/mini_magick) to\r\nresize and crop images.\r\n\r\nIf you plan to support thumbnails raw files, imagemagick delegate raw processing\r\nto [ufraw](http://ufraw.sourceforge.net/).\r\n\r\nOn OS X:\r\n\r\n    $ brew install ufraw # Optional, for processing cr2, raw, etc\r\n    $ brew install imagemagick\r\n    $ gem install mini_magick\r\n\r\n### Text thumbnails\r\n\r\nThumbkit uses [MiniMagick](https://github.com/probablycorey/mini_magick) to\r\nrender text files, and depends on both Ghostscript and ImageMagick\r\n\r\nOn OS X:\r\n\r\n    $ brew install ghostscript\r\n    $ brew install imagemagick\r\n    $ gem install mini_magick\r\n\r\n### HTML thumbnails\r\n\r\nHTML thumbnails are not yet supported, but the plan is to use phantomjs to\r\nrender html files.\r\n\r\n### Audio thumbnails\r\n\r\nThumbkit uses the [waveform](https://github.com/benalavi/waveform) gem to render\r\naudio files. [waveform](https://github.com/benalavi/waveform) depends on\r\nlibsndfile. **ffmpeg** is required in order to generate thumbnails from anything\r\nother than .wav files.\r\n\r\nSee https://github.com/benalavi/waveform for more on requirements.\r\n\r\n    $ brew install ffmpeg # Optional for mp3\r\n    $ brew install libsndfile\r\n\r\n\r\nNOTE: As of 0.0.3 waveform fails on mono files\r\n([benalavi/waveform#4](https://github.com/benalavi/waveform/issues/4),\r\n[benalavi/waveform#5](https://github.com/benalavi/waveform/issues/5)).\r\nI've forked and fixed the issue (see\r\n[benalavi/waveform#6](https://github.com/benalavi/waveform/pull/6)). Until my\r\nfix gets merged in you can use https://github.com/amiel/waveform/tree/thumbkit.\r\nLike so:\r\n\r\n\r\n```ruby\r\ngem 'thumbkit'\r\ngem 'waveform', git: 'https://github.com/amiel/waveform', branch: 'thumbkit'\r\ngem 'oily_png' # Optional, for presumably faster audio thumbnails\r\n```\r\n\r\n## Usage\r\n\r\nThumbkit takes a path to a file, and saves a thumbnail for that file regardless\r\nof type. Certain types require different gems, but none are dependencies so\r\nyou'll have to install them yourself.\r\n\r\n### Image thumbnails\r\n\r\n```ruby\r\n  Thumbkit.new('path/to/image.jpg').write_thumbnail # => 'path/to/image.jpg'\r\n```\r\n\r\nWill write a 200x200 cropped image to `path/to/image.jpg`.\r\n\r\nTo get an image resized to fit instead of cropped:\r\n\r\n```ruby\r\n  Thumbkit.new('path/to/image.jpg', crop: false).write_thumbnail\r\n```\r\n\r\nThe format of the output file will depend on the extension of the output path\r\nand defaults to the same as the input file.\r\n\r\n### Text thumbnails\r\n\r\n```ruby\r\n  text = Thumbkit.new('path/to/text_file.txt')\r\n\r\n  text.write_thumbnail(nil, {\r\n    width: 160, height: 160,\r\n    colors: { foreground: '#663854' },\r\n    font: { pointsize: '18' },\r\n  }) # => 'path/to/text_file.png'\r\n```\r\n\r\nWill write a 160x160 cropped image to `path/to/text_file.png`.\r\n\r\nThe format of output will depend on the extension of the output path provided\r\nbut defaults to .png.\r\n\r\n#### RTL support\r\n\r\n```ruby\r\n  text = Thumbkit.new('path/to/text_file.txt')\r\n  text.write_thumbnail(nil, font: { direction: 'right-to-left' }) # Force RTL\r\n```\r\n\r\n`direction` options:\r\n\r\n* `nil`: don't specify the option to imagemagick (OS default)\r\n* `:auto`: try to detect. Currently, this switches to `'right-to-left'` if there\r\n  are *any* RTL characters in the input. This is the default.\r\n* `'right-to-left'`, `'left-to-right'`: force LTR or RTL\r\n\r\n### Audio thumbnails\r\n\r\n```ruby\r\n  audio = Thumbkit.new('path/to/audio.mp3')\r\n  audio.write_thumbnail('path/to/ouput.png', {\r\n    colors: { foreground: '#ffffff', background: '#000000' },\r\n  }) # => 'path/to/output.png'\r\n```\r\n\r\nWill write a 200x200 cropped image to `path/to/output.png`.\r\n\r\nNote that while imagemagick supports most color specification formats, waveform\r\nonly takes 6 digit hex values. However, there is one special case for the symbol\r\n:transparent.\r\n\r\nAudio thumbnails only support PNG output. A png file will be created regardless\r\nof the extension of the output file provided.\r\n\r\n### Composite thumbnails\r\n\r\n```ruby\r\n  composite = Thumbkit.new(['path/to/audio.mp3', 'path/to/text_file.txt'])\r\n  composite.write_thumbnail('path/to/collection.png')\r\n```\r\n\r\n### CarrierWave usage\r\n\r\n```ruby\r\n  class MyUploader < CarrierWave::Uploader::Base\r\n    include Thumbkit::Adapters::CarrierWave\r\n\r\n    version :thumbnail do\r\n      # See Configuration below for more about options.\r\n      process thumbkit: [200, 200, { colors: { foreground: '#cccccc' } }]\r\n\r\n      # This tells CarrierWave where the version file can be found since\r\n      # thumbkit can write a to a file with a different extension than the\r\n      # original.\r\n      #\r\n      # See https://github.com/jnicklas/carrierwave/wiki/How-to%3A-Customize-your-version-file-names\r\n      # for more about\r\n      def full_filename(for_file = model.file.file)\r\n        [version_name, thumbkit_filename(for_file)].join('_')\r\n      end\r\n    end\r\n  end\r\n```\r\n\r\n## Configuration\r\n\r\nAll settings can be set globally. These are the defaults:\r\n\r\n```ruby\r\n  Thumbkit.defaults = {\r\n    width: 200, height: 200,\r\n    gravity: 'Center',\r\n    crop: true,\r\n    colors: { foreground: '#888888', background: '#eeeeee' },\r\n    font: {\r\n      family: 'Arial-Regular',\r\n      pointsize: '18',\r\n      direction: :auto,\r\n    },\r\n  }\r\n```\r\n\r\nSetting `Thumbkit.defaults=` will deep merge. So setting one option is possible\r\nwith:\r\n\r\n```ruby\r\n  Thumbkit.defaults = { colors: { foreground: '#FF69B4' } } # HOT PINK\r\n```\r\n\r\n#### Font options\r\n\r\nThe list of fonts available to imagemagick can be found with\r\n`identify -list Font`\r\n\r\n#### Gravity Options\r\n\r\nA list of gravity options can be found with `identify -list Gravity`\r\n\r\nSee http://www.imagemagick.org/script/command-line-options.php#gravity for more\r\ninformation.\r\n\r\n#### Processors\r\n\r\nBuilt-in processors can be found in `lib/thumbkit/processor`.\r\n\r\nAdding a processor mapping:\r\n\r\n```ruby\r\nThumbkit.processors['jpeg'] = 'Image'\r\n```\r\n\r\n##### Custom processors\r\n\r\n```ruby\r\nclass Thumbkit::Processor::Doc < Thumbkit::Processor\r\n  def write\r\n    # use `path` to generate `outfile`\r\n\r\n    # always return the generated filename\r\n    outfile\r\n  end\r\nend\r\n\r\nThumbkit.processors['doc'] = 'Doc'\r\n```\r\n\r\n## Other plans\r\n\r\n* Optionally accept a StringIO instead of a pathname\r\n* Maybe use filemagic/mime-type if available\r\n* Paperclip processor\r\n* Processors:\r\n  * HTML\r\n  * PDF\r\n  * Video\r\n\r\n## Known Issues\r\n\r\n* If the output file has an uppercase extension, image processing may break.\r\n  This will not be an issue if you are not supplying the output filename as\r\n  `Thumbkit::Image` will always pick a lowercase extension by default.\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Run the test suite to make sure all tests pass before you start (`guard`)\r\n4. Make your changes\r\n5. Run the test suite again to make sure you didn't break anything existing (`guard`)\r\n6. Commit your changes (`git commit -am 'Added some feature'`)\r\n7. Push to the branch (`git push origin my-new-feature`)\r\n8. Create new Pull Request\r\n\r\n## Testing\r\n\r\nTests run in guard. If you don't like guard, a pull request on `Rakefile` would\r\nbe welcome.\r\n\r\nOutput files are placed in `spec/tmp` which is created automatically before each\r\ntest run and deleted automatically afterward unless `spec/tmp/.keep` exists. If\r\nyou would like to inspect the generated output files, create a file at\r\n`spec/tmp/.keep`:\r\n\r\n    $ mkdir spec/tmp; touch spec/tmp/.keep\r\n\r\nMany of the tests just verify that an image was created of the right type and\r\nsize, but do not actually verify that they have the correct content so it is\r\ngood to inspect the generated files.\r\n","tagline":"A unified API for generating thumbnail images from image, audio, and text sources.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}